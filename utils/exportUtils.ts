/**
 * Export utilities for infographic format conversion.
 * v1.4.0 Feature: Export Format Options
 */

import { jsPDF } from 'jspdf';
import JSZip from 'jszip';
import { AspectRatio, ImageSize, ExportFormat } from '../types';

/**
 * Convert base64 data URL to blob
 */
const dataURLtoBlob = (dataURL: string): Blob => {
  const parts = dataURL.split(',');
  const mime = parts[0].match(/:(.*?);/)?.[1] || 'image/png';
  const bstr = atob(parts[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
};

/**
 * Get dimension in pixels based on image size
 */
const getSizeDimension = (size: ImageSize): number => {
  switch (size) {
    case ImageSize.Resolution_1K:
      return 1024;
    case ImageSize.Resolution_2K:
      return 2048;
    case ImageSize.Resolution_4K:
      return 4096;
    default:
      return 2048;
  }
};

/**
 * Calculate width and height based on aspect ratio
 */
const calculateDimensions = (size: ImageSize, aspectRatio: AspectRatio): { width: number; height: number } => {
  const dimension = getSizeDimension(size);

  switch (aspectRatio) {
    case AspectRatio.Square:
      return { width: dimension, height: dimension };
    case AspectRatio.Landscape:
      // 16:9
      return { width: dimension, height: Math.round(dimension * 9 / 16) };
    case AspectRatio.Portrait:
      // 9:16
      return { width: Math.round(dimension * 9 / 16), height: dimension };
    case AspectRatio.StandardLandscape:
      // 4:3
      return { width: dimension, height: Math.round(dimension * 3 / 4) };
    case AspectRatio.StandardPortrait:
      // 3:4
      return { width: Math.round(dimension * 3 / 4), height: dimension };
    default:
      return { width: dimension, height: dimension };
  }
};

/**
 * Export infographic as PDF
 * Creates a PDF document with the embedded PNG image
 */
export const exportAsPDF = (
  imageDataURL: string,
  filename: string,
  size: ImageSize,
  aspectRatio: AspectRatio
): void => {
  const { width, height } = calculateDimensions(size, aspectRatio);

  // Calculate PDF dimensions in mm (at 72 DPI)
  const mmWidth = (width / 72) * 25.4;
  const mmHeight = (height / 72) * 25.4;

  // Create PDF with exact dimensions
  const pdf = new jsPDF({
    orientation: width > height ? 'landscape' : 'portrait',
    unit: 'mm',
    format: [mmWidth, mmHeight]
  });

  // Add image to fill entire page
  pdf.addImage(imageDataURL, 'PNG', 0, 0, mmWidth, mmHeight);

  // Add metadata
  pdf.setProperties({
    title: `${filename} - InfoGraphix AI`,
    subject: 'Generated Infographic',
    creator: 'InfoGraphix AI',
    keywords: 'infographic, visualization, data'
  });

  // Download
  pdf.save(`${filename}.pdf`);
};

/**
 * Export infographic as SVG
 * Wraps PNG in an SVG container (not true vector conversion)
 */
export const exportAsSVG = (
  imageDataURL: string,
  filename: string,
  size: ImageSize,
  aspectRatio: AspectRatio
): void => {
  const { width, height } = calculateDimensions(size, aspectRatio);

  // Create SVG with embedded PNG
  const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
     width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <title>${filename}</title>
  <desc>Generated by InfoGraphix AI</desc>
  <image width="${width}" height="${height}" xlink:href="${imageDataURL}"/>
</svg>`;

  // Create blob and download
  const blob = new Blob([svg], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${filename}.svg`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

/**
 * Export infographic as PNG (direct download)
 */
export const exportAsPNG = (
  imageDataURL: string,
  filename: string
): void => {
  const a = document.createElement('a');
  a.href = imageDataURL;
  a.download = `${filename}.png`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
};

/**
 * Package multiple resolutions as ZIP
 * Note: This requires regenerating the infographic at different resolutions
 */
export const exportMultiResolution = async (
  images: Array<{ size: ImageSize; dataURL: string }>,
  baseFilename: string
): Promise<void> => {
  const zip = new JSZip();

  // Add each resolution to the ZIP
  for (const { size, dataURL } of images) {
    const blob = dataURLtoBlob(dataURL);
    const filename = `${baseFilename}_${size}.png`;
    zip.file(filename, blob);
  }

  // Add README
  const readme = `InfoGraphix AI - Multi-Resolution Export
Generated: ${new Date().toISOString()}

This package contains the following resolutions:
${images.map(img => `- ${img.size} (${getSizeDimension(img.size)}px)`).join('\n')}

All images are in PNG format for maximum compatibility.
`;

  zip.file('README.txt', readme);

  // Generate and download ZIP
  const zipBlob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(zipBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${baseFilename}_multi-res.zip`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

/**
 * Main export function that routes to appropriate handler
 */
export const exportInfographic = async (
  format: ExportFormat,
  imageDataURL: string,
  filename: string,
  size: ImageSize,
  aspectRatio: AspectRatio,
  multiResImages?: Array<{ size: ImageSize; dataURL: string }>
): Promise<void> => {
  // Sanitize filename
  const safeFilename = filename.replace(/[^a-z0-9_\-]/gi, '_');

  switch (format) {
    case ExportFormat.PNG:
      exportAsPNG(imageDataURL, safeFilename);
      break;
    case ExportFormat.PDF:
      exportAsPDF(imageDataURL, safeFilename, size, aspectRatio);
      break;
    case ExportFormat.SVG:
      exportAsSVG(imageDataURL, safeFilename, size, aspectRatio);
      break;
    case ExportFormat.MultiRes:
      if (!multiResImages || multiResImages.length === 0) {
        throw new Error('Multi-resolution export requires multiple images');
      }
      await exportMultiResolution(multiResImages, safeFilename);
      break;
    default:
      throw new Error(`Unsupported export format: ${format}`);
  }
};

/**
 * Create a batch ZIP archive from multiple infographics
 */
export const exportBatchAsZip = async (
  items: Array<{ filename: string; dataURL: string }>,
  archiveName: string
): Promise<void> => {
  const zip = new JSZip();

  // Add each infographic to the ZIP
  for (const { filename, dataURL } of items) {
    const blob = dataURLtoBlob(dataURL);
    const safeFilename = filename.replace(/[^a-z0-9_\-]/gi, '_');
    zip.file(`${safeFilename}.png`, blob);
  }

  // Add metadata
  const metadata = {
    generated: new Date().toISOString(),
    count: items.length,
    generator: 'InfoGraphix AI v1.4.0',
    format: 'PNG'
  };

  zip.file('metadata.json', JSON.stringify(metadata, null, 2));

  // Generate and download ZIP
  const zipBlob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(zipBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${archiveName}.zip`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};
